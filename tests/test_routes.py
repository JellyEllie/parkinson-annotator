"""
Tests for Flask routes defined in routes.py.

These tests validate:
- UI routes return the correct templates
- Search endpoint returns correct responses and status codes
- Upload endpoint handles success, errors, and duplicates correctly

External dependencies (database, APIs, filesystem) are mocked

Credit: tests generated by ChatGPT then checked/added to/tested.
"""

import io
import pytest
from flask import Flask

from parkinsons_annotator.modules.routes import route_blueprint

### FIXTURES ###

# Flask app fixture
@pytest.fixture
def app(tmp_path):
    """
    Create a minimal Flask app for testing routes.

    - Registers the routes blueprint
    - Uses a temporary upload folder
    - Enables TESTING mode
    """
    app = Flask(__name__)
    app.config["TESTING"] = True
    app.config["UPLOAD_FOLDER"] = str(tmp_path)

    app.register_blueprint(route_blueprint)
    return app


@pytest.fixture
def client(app):
    """
    Flask test client used to simulate HTTP requests.
    """
    return app.test_client()

# Fake session class for upload tests
class FakeSession:
    """
    Minimal stand-in for a SQLAlchemy session.
    Implements only what routes.upload_file() uses.
    """

    def commit(self):
        pass

    def rollback(self):
        pass


### TESTS ###

# Test UI routes:

def test_index_route(client, monkeypatch):
    """
    GET / should load the main interface template.

    render_template is mocked so the test does not
    depend on the presence of HTML files.
    """
    # Mock render_template to return a fixed string
    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.render_template",
        lambda template: f"rendered {template}"
    )

    response = client.get("/")

    assert response.status_code == 200
    assert b"interface_package.html" in response.data


def test_about_route(client, monkeypatch):
    """
    GET /about should load the info template.
    """
    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.render_template",
        lambda template: f"rendered {template}"
    )

    response = client.get("/about")

    assert response.status_code == 200
    assert b"info.html" in response.data

# Search Route

def test_search_success_gene_symbol(client, monkeypatch):
    """
    Valid gene_symbol search returns results with correct column ordering.
    """

    # Fake search results returned from database_list()
    mock_results = [
        {"hgvs": "HGVS1", "classification": "Pathogenic", "name": "Alice"},
        {"hgvs": "HGVS1", "classification": "Pathogenic", "name": "Bob"},
    ]

    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.database_list",
        lambda **kwargs: mock_results
    )

    response = client.post(
        "/search",
        json={"query": "GENE1", "category": "gene_symbol"}
    )

    assert response.status_code == 200

    data = response.get_json()

    # Column order must match UI expectations
    assert data["column_order"] == ["hgvs", "classification", "name"]
    assert len(data["results"]) == 2


def test_search_missing_fields(client, monkeypatch):
    """
    Missing search fields should return HTTP 400.
    """
    from parkinsons_annotator.modules.database_search import SearchFieldEmptyError

    def raise_missing(*args, **kwargs):
        raise SearchFieldEmptyError

    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.database_list",
        raise_missing
    )

    response = client.post("/search", json={})

    assert response.status_code == 400
    assert response.get_json()["message"] == "Missing search fields"


def test_search_no_matches(client, monkeypatch):
    """
    Searching with no matches should return HTTP 404.
    """
    from parkinsons_annotator.modules.database_search import NoMatchingRecordsError

    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.database_list",
        lambda **kwargs: (_ for _ in ()).throw(NoMatchingRecordsError)
    )

    response = client.post(
        "/search",
        json={"query": "FAKEGENE", "category": "gene_symbol"}
    )

    assert response.status_code == 404
    assert response.get_json()["message"] == "No matching records found"

# Upload Route

def test_upload_no_file(client):
    """
    POST /upload without a file should return HTTP 400.
    """
    response = client.post("/upload")
    assert response.status_code == 400


def test_upload_empty_filename(client):
    """
    POST /upload with an empty filename should return HTTP 400.
    """
    data = {"file": (io.BytesIO(b""), "")}

    response = client.post(
        "/upload",
        data=data,
        content_type="multipart/form-data"
    )

    assert response.status_code == 400


def test_upload_success(client, monkeypatch):
    """
    Valid upload path:
    - file saved
    - variant enrichment mocked
    - DB insert mocked
    - commit succeeds
    """

    # Mock DB/session handling
    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.get_db_session",
        lambda: FakeSession()
    )
    monkeypatch.setattr("parkinsons_annotator.modules.routes.close_db_session", lambda: None)

    # Mock data processing pipeline
    monkeypatch.setattr("parkinsons_annotator.modules.routes.load_single_file", lambda path: None)
    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.compare_uploaded_vs_existing",
        lambda *args, **kwargs: {"exists": False, "identical": False}
    )
    monkeypatch.setattr("parkinsons_annotator.modules.routes.fill_variant_notation", lambda df: df)
    monkeypatch.setattr("parkinsons_annotator.modules.routes.enrich_hgvs", lambda df, session=None: df)
    monkeypatch.setattr("parkinsons_annotator.modules.routes.enrich_clinvar", lambda df, session=None: df)
    monkeypatch.setattr("parkinsons_annotator.modules.routes.insert_dataframe_to_db", lambda *a, **k: None)

    # Fake uploaded DataFrame cache
    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.dataframes",
        {"Alice": object()}
    )

    data = {
        "file": (io.BytesIO(b"chromosome,position,ref,alt\n1,1,A,T"), "Alice.csv")
    }

    response = client.post(
        "/upload",
        data=data,
        content_type="multipart/form-data"
    )

    assert response.status_code == 200
    assert b"uploaded and processed successfully" in response.data

def test_upload_duplicate_rejected(client, monkeypatch):
    """
    Upload is rejected with 409 if patient exists
    and uploaded variants are identical.
    """
    from parkinsons_annotator.modules import routes

    class FakeSession:
        def commit(self): pass
        def rollback(self): pass

    fake_session = FakeSession()

    # Mock DB session handling
    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.get_db_session",
        lambda: fake_session
    )
    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.close_db_session",
        lambda *a, **k: None
    )

    # Repopulate dataframes AFTER clear()
    def fake_load_single_file(path):
        routes.dataframes["Alice"] = "dummy_df"

    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.load_single_file",
        fake_load_single_file
    )

    # Force duplicate detection
    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.compare_uploaded_vs_existing",
        lambda patient, df, session: {
            "exists": True,
            "identical": True
        }
    )

    # Prevent downstream processing
    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.fill_variant_notation",
        lambda df: df
    )
    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.enrich_hgvs",
        lambda df, session=None: df
    )
    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.enrich_clinvar",
        lambda df, session=None: df
    )
    monkeypatch.setattr(
        "parkinsons_annotator.modules.routes.insert_dataframe_to_db",
        lambda *a, **k: None
    )

    response = client.post(
        "/upload",
        data={"file": (io.BytesIO(b"dummy"), "Alice.csv")},
        content_type="multipart/form-data"
    )

    # Check that upload was rejected
    assert response.status_code == 409
    assert b"Upload rejected" in response.data
