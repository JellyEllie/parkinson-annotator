"""
Tests main.py app script functions:
open_browser(),
create_app(),
main().

Credit: tests generated by ChatGPT then checked/added to/tested.
"""

from pathlib import Path
import types

import parkinsons_annotator.main as main_mod

# Test open_browser
def test_open_browser_opens_correct_url(monkeypatch):
    """open_browser should open the local Flask URL."""
    opened = {}

    def fake_open(url):
        opened["url"] = url

    monkeypatch.setattr(
        main_mod.webbrowser,
        "open_new",
        fake_open
    )

    main_mod.open_browser()

    assert opened["url"] == "http://127.0.0.1:5000/"


# Test create_app
def test_create_app_configures_flask_app(tmp_path, monkeypatch):
    """
    create_app should:
    - create Flask app
    - set upload folder in instance path
    - set DB_NAME in instance path
    - register blueprint
    """

    # Force instance_path to tmp_path
    monkeypatch.setattr(
        main_mod,
        "Path",
        lambda *a, **k: tmp_path if "__file__" in a[0] else Path(*a)
    )

    app = main_mod.create_app()

    # Confirm app exists and is configured correctly
    assert app is not None
    assert app.config["UPLOAD_FOLDER"].endswith("uploads")
    assert app.config["DB_NAME"].endswith(".db")

    # Blueprint registered
    blueprint_names = [bp.name for bp in app.blueprints.values()]
    assert "routes" in blueprint_names

    # Instance folder exists
    assert Path(app.instance_path).exists()


# Test 'main'

def test_main_creates_db_and_tables_when_missing(monkeypatch, tmp_path):
    """
    If DB does not exist:
    - create_db_engine is called
    - create_tables is called
    - initial data is loaded
    """

    # Iniatially set count for each function at 0 calls
    calls = {
        "create_engine": 0,
        "create_tables": 0,
        "load_data": 0,
        "run": 0,
        "timer": 0,
    }

    # Fake Flask app
    class FakeApp:
        config = {"DB_NAME": str(tmp_path / "test.db")}

        def app_context(self):
            return self

        def __enter__(self): return self
        def __exit__(self, *a): pass

        def run(self, *a, **k):
            calls["run"] += 1

    # Mock create_app to fake app
    monkeypatch.setattr(main_mod, "create_app", lambda: FakeApp())

    # Count calls to mocked functions
    monkeypatch.setattr(
        main_mod,
        "create_db_engine",
        lambda: calls.__setitem__("create_engine", calls["create_engine"] + 1)
    )
    monkeypatch.setattr(
        main_mod,
        "create_tables",
        lambda: calls.__setitem__("create_tables", calls["create_tables"] + 1)
    )
    monkeypatch.setattr(
        main_mod,
        "load_and_insert_data",
        lambda: calls.__setitem__("load_data", calls["load_data"] + 1)
    )
    monkeypatch.setattr(main_mod, "has_full_data", lambda: False)

    # Prevent browser + thread
    monkeypatch.setattr(main_mod.threading, "Timer", lambda *a, **k: types.SimpleNamespace(start=lambda: calls.__setitem__("timer", 1)))

    main_mod.main()

    # Check that all functions have been called once
    assert calls["create_engine"] == 1
    assert calls["create_tables"] == 1
    assert calls["load_data"] == 1
    assert calls["run"] == 1
    assert calls["timer"] == 1


def test_main_skips_db_creation_if_exists(monkeypatch, tmp_path):
    """
    If DB exists:
    - create_db_engine is NOT called
    - create_tables is NOT called
    """

    # Iniatially set count for each function at 0 calls
    calls = {
        "create_engine": 0,
        "create_tables": 0,
        "run": 0,
    }

    # Give test an existing DB
    db_file = tmp_path / "existing.db"
    db_file.touch()

    # Create fake app
    class FakeApp:
        config = {"DB_NAME": str(db_file)}

        def app_context(self):
            return self

        def __enter__(self): return self
        def __exit__(self, *a): pass

        def run(self, *a, **k):
            calls["run"] += 1

    monkeypatch.setattr(main_mod, "create_app", lambda: FakeApp())

    # Count calls to mocked functions
    monkeypatch.setattr(
        main_mod,
        "create_db_engine",
        lambda: calls.__setitem__("create_engine", calls["create_engine"] + 1)
    )
    monkeypatch.setattr(
        main_mod,
        "create_tables",
        lambda: calls.__setitem__("create_tables", calls["create_tables"] + 1)
    )
    monkeypatch.setattr(main_mod, "has_full_data", lambda: True)

    monkeypatch.setattr(
        main_mod.threading,
        "Timer",
        lambda *a, **k: types.SimpleNamespace(start=lambda: None)
    )

    main_mod.main()

    # Check create_engine and create_tables were NOT called
    assert calls["create_engine"] == 0
    assert calls["create_tables"] == 0
    assert calls["run"] == 1


def test_main_handles_data_load_error(monkeypatch, tmp_path):
    """
    load_and_insert_data exceptions should be caught
    and should NOT stop the app from running.
    """

    class FakeApp:
        config = {"DB_NAME": str(tmp_path / "db.db")}

        def app_context(self):
            return self

        def __enter__(self): return self
        def __exit__(self, *a): pass

        def run(self, *a, **k):
            pass

    monkeypatch.setattr(main_mod, "create_app", lambda: FakeApp())
    monkeypatch.setattr(main_mod, "has_full_data", lambda: False)
    monkeypatch.setattr(main_mod, "create_db_engine", lambda: None)
    monkeypatch.setattr(main_mod, "create_tables", lambda: None)
    monkeypatch.setattr(
        main_mod,
        "load_and_insert_data",
        lambda: (_ for _ in ()).throw(RuntimeError("boom"))
    )
    monkeypatch.setattr(
        main_mod.threading,
        "Timer",
        lambda *a, **k: types.SimpleNamespace(start=lambda: None)
    )

    # Should not raise
    main_mod.main()
