"""
Tests for data_extraction.py
Covers: load_single_file, fill_variant_notation, enrich_hgvs, enrich_clinvar,
insert_dataframe_to_db, load_and_insert_data

Credit: tests generated by ChatGPT then checked/added to/tested.
"""

import pytest
import pandas as pd
from unittest.mock import patch
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, clear_mappers

from parkinsons_annotator.modules.data_extraction import (
    dataframes,
    load_single_file,
    fill_variant_notation,
    enrich_hgvs,
    enrich_clinvar,
    insert_dataframe_to_db,
    load_and_insert_data,
    CLINVAR_FIELDS
)
from parkinsons_annotator.modules.models import Base, Variant, Patient, Connector, Genes

### FIXTURES ###

# Create database setup fixture
@pytest.fixture(scope="function")
def db_session():
    """Create a fresh in-memory DB for testing."""
    engine = create_engine("sqlite:///:memory:")
    Base.metadata.create_all(engine)
    Session = sessionmaker(bind=engine)
    session = Session()
    yield session
    session.close()
    engine.dispose()


@pytest.fixture
def real_session(tmp_path):
    """Provide a real SQLAlchemy session backed by a temporary SQLite DB."""
    engine = create_engine(f"sqlite:///{tmp_path}/test.db")
    Base.metadata.create_all(engine)

    Session = sessionmaker(bind=engine)
    session = Session()

    yield session

    session.close()
    engine.dispose()


# Creates a minimal DataFrame for testing
@pytest.fixture
def sample_df():
    """Minimal DataFrame representing patient variants as imported from CSV/VCF"""
    return pd.DataFrame([{
        "chromosome": "17",
        "position": "45983420",
        "ref": "A",
        "alt": "T",
        "vcf_form": None,
        "hgvs": None,
        "gene_symbol": None,
        "cdna_change": None,
        "clinvar_id": None,
        "clinvar_accession": None,
        "classification": None,
        "num_records": None,
        "review_status": None,
        "associated_condition": None,
        "clinvar_url": None
    }])


# DataFrame specifically for ClinVar enrichment tests
@pytest.fixture
def sample_df_with_missing_clinvar():
    """
    DataFrame with valid HGVS but missing ClinVar data.
    This ensures the enrich_clinvar function will attempt API enrichment.
    """
    return pd.DataFrame([{
        "chromosome": "17",
        "position": "45983420",
        "ref": "A",
        "alt": "T",
        "vcf_form": "17:45983420:A:T",
        "hgvs": "NM_000111.1:c.100A>T",  # Valid HGVS
        "gene_symbol": None,
        "cdna_change": None,
        "clinvar_id": None,
        "clinvar_accession": None,
        "classification": None,
        "num_records": None,
        "review_status": None,
        "associated_condition": None,
        "clinvar_url": None
    }])


# Flask app context fixture
@pytest.fixture
def flask_app():
    """Create a minimal Flask app for testing."""
    from flask import Flask
    app = Flask(__name__)
    app.config['UPLOAD_FOLDER'] = '/tmp/test_uploads'
    app.config['TESTING'] = True
    return app


### TESTS ###

# Test that a single file is uploaded and stored in a dataframe
def test_load_single_file_creates_dataframe(tmp_path):
    """load_single_file stores DataFrame in dataframes dict"""
    # Mock filesystem
    file_path = tmp_path / "Alice.csv"
    file_path.write_text("chromosome,position,ref,alt\n17,45983420,A,T\n")
    # Clear all existing df information
    dataframes.clear()
    # Run load_single_file on test file
    load_single_file(file_path)
    # Check that dataframes dict contains expected DataFrame
    assert "Alice" in dataframes
    df = dataframes["Alice"]
    # Check that DataFrame has expected columns and shape
    assert "chromosome" in df.columns # Confirm df has chromosome column
    assert df.shape[0] == 1 # Confirm Alice's df has 1 row as in mock data


def test_fill_variant_notation(sample_df):
    """fill_variant_notation correctly populates vcf_form column of sample df"""
    df = fill_variant_notation(sample_df)
    assert df.at[0, "vcf_form"] == "17:45983420:A:T"


def test_enrich_hgvs_skips_existing_variant(db_session, sample_df):
    """enrich_hgvs fills hgvs correctly from DB instead of API when exisiting_variant_check returns True"""
    # Mock existing_variant_check to pretend variant exists in DB and mock API call
    with patch("parkinsons_annotator.modules.data_extraction.existing_variant_check") as mock_check, \
         patch("parkinsons_annotator.modules.data_extraction.fetch_variant_validator") as mock_api:
        # Give existing_variant_check a dummy return value we expect to see
        mock_check.return_value = {"hgvs": "NM_000111.1:c.100A>T"}
        # Give API call a dummy response that should not be used
        mock_api.return_value = {"HGVS nomenclature": "SHOULD_NOT_BE_USED"}
        # Fill variant notation to populate vcf_form column
        df = fill_variant_notation(sample_df)
        # Call enrich_hgvs
        df = enrich_hgvs(df, db_session, throttle=0)
        # Check that hgvs column is populated with expected value
        assert df.at[0, "hgvs"] == "NM_000111.1:c.100A>T"
        # API should not be called
        mock_api.assert_not_called()


def test_enrich_clinvar_loads_from_db(db_session, sample_df):
    """enrich_clinvar loads data from DB when variant exists with ClinVar data"""

    # Set up sample data
    sample_df['clinvar_id'] = None
    sample_df['hgvs'] = "NM_000111.1:c.100A>T"

    df = fill_variant_notation(sample_df)

    # Mock existing variant in DB with ClinVar data
    existing_variant = {
        "hgvs": "NM_000111.1:c.100A>T",
        "clinvar_id": "12345",
        "gene_symbol": "GENE1",
        "cdna_change": "c.100A>T",
        "clinvar_accession": "VCV000012345",
        "classification": "Pathogenic",
        "num_records": "5",
        "review_status": "reviewed by expert panel",
        "associated_condition": "Test Disease",
        "clinvar_url": "https://www.ncbi.nlm.nih.gov/clinvar/variation/12345/"
    }

    with patch("parkinsons_annotator.modules.data_extraction.existing_variant_check") as mock_check, \
            patch("parkinsons_annotator.modules.data_extraction.extract_clinvar_annotation") as mock_clinvar:
        # Mock the existing variant (i.e. pretend variant exists in DB without running actual check function)
        mock_check.return_value = existing_variant

        # Call enrich_clinvar on test df
        df = enrich_clinvar(df, db_session, throttle=0)

        # API should NOT be called when data exists in DB
        mock_clinvar.assert_not_called()

        # All ClinVar fields should be loaded from DB, so should be the same as existing_variant
        for col in CLINVAR_FIELDS.values():
            assert df.at[0, col] == existing_variant[col]


def test_enrich_clinvar_api_updates_all_fields(db_session, sample_df_with_missing_clinvar):
    """Verify that enrich_clinvar correctly maps ALL fields from API response to DataFrame."""

    # Use fixture data with missing clinvar fields
    df = sample_df_with_missing_clinvar.copy()

    # Ensure vcf_form is populated (required for existing_variant_check)
    if df.at[0, "vcf_form"] is None:
        df = fill_variant_notation(df)

    # Create realistic mock API response matching actual ClinVar structure
    mock_api_response = {
        "Gene symbol": "BRCA1",
        "cDNA change": "c.100A>T",
        "ClinVar variant ID": "123456",
        "ClinVar accession": "VCV000123456.1",
        "ClinVar consensus classification": "Pathogenic",
        "Number of submitted records": "10",
        "Review status": "criteria provided, multiple submitters, no conflicts",
        "Associated condition": "Breast-ovarian cancer, familial, susceptibility to, 1",
        "ClinVar record URL": "https://www.ncbi.nlm.nih.gov/clinvar/variation/123456/"
    }

    # Mock existing variant check and mock API call
    with patch("parkinsons_annotator.modules.data_extraction.existing_variant_check") as mock_check, \
         patch("parkinsons_annotator.modules.data_extraction.extract_clinvar_annotation") as mock_api:

        # Variant doesn't exist in DB (returns None)
        mock_check.return_value = None

        # API returns our mock response
        mock_api.return_value = mock_api_response

        # Call the function
        df = enrich_clinvar(df, db_session, throttle=0)

        # Assertions verify each field was updated correctly
        assert df.at[0, "gene_symbol"] == "BRCA1", f"Expected 'BRCA1', got '{df.at[0, 'gene_symbol']}'"
        assert df.at[0, "cdna_change"] == "c.100A>T", f"Expected 'c.100A>T', got '{df.at[0, 'cdna_change']}'"
        assert df.at[0, "clinvar_id"] == "123456", f"Expected '123456', got '{df.at[0, 'clinvar_id']}'"
        assert df.at[0, "clinvar_accession"] == "VCV000123456.1", f"Expected 'VCV000123456.1', got '{df.at[0, 'clinvar_accession']}'"
        assert df.at[0, "classification"] == "Pathogenic", f"Expected 'Pathogenic', got '{df.at[0, 'classification']}'"
        assert df.at[0, "num_records"] == "10", f"Expected '10', got '{df.at[0, 'num_records']}'"
        assert df.at[0, "review_status"] == "criteria provided, multiple submitters, no conflicts"
        assert df.at[0, "associated_condition"] == "Breast-ovarian cancer, familial, susceptibility to, 1"
        assert df.at[0, "clinvar_url"] == "https://www.ncbi.nlm.nih.gov/clinvar/variation/123456/"

        # Verify NO field is "Not found in ClinVar" when API succeeds
        for col in CLINVAR_FIELDS.values():
            assert df.at[0, col] != "Not found in ClinVar", \
                f"Field {col} should not be 'Not found in ClinVar' when API succeeds"


def test_enrich_clinvar_handles_partial_api_response(db_session, sample_df_with_missing_clinvar):
    """
    Verify enrich_clinvar handles partial API responses (some fields missing).
    Real API might not return all fields for every variant.
    """

    # Use fixture data with missing clinvar fields
    df = sample_df_with_missing_clinvar.copy()

    # Ensure vcf_form is populated
    if df.at[0, "vcf_form"] is None:
        df = fill_variant_notation(df)

    # API returns only some fields
    partial_response = {
        "Gene symbol": "BRCA1",
        "ClinVar variant ID": "123456",
        "ClinVar consensus classification": "Pathogenic",
        # Other fields missing (will return None from .get())
    }

    # Mock existing variant check and mock API call
    with patch("parkinsons_annotator.modules.data_extraction.existing_variant_check") as mock_check, \
            patch("parkinsons_annotator.modules.data_extraction.extract_clinvar_annotation") as mock_api:
        mock_check.return_value = None
        mock_api.return_value = partial_response

        # Call enrich_clinvar
        df = enrich_clinvar(df, db_session, throttle=0)

        # Fields that were in response should be set
        assert df.at[0, "gene_symbol"] == "BRCA1", f"Expected 'BRCA1', got '{df.at[0, 'gene_symbol']}'"
        assert df.at[0, "clinvar_id"] == "123456"
        assert df.at[0, "classification"] == "Pathogenic"

        # Fields that were NOT in response should be "Not found in ClinVar"
        assert df.at[0, "cdna_change"] == "Not found in ClinVar"
        assert df.at[0, "clinvar_accession"] == "Not found in ClinVar"


def test_enrich_clinvar_skips_when_hgvs_missing(db_session, sample_df_with_missing_clinvar):
    """Verify enrich_clinvar skips API call and sets 'Not found in ClinVar' when hgvs is missing."""

    # Use fixture data with missing hgvs
    df = sample_df_with_missing_clinvar.copy()

    # Set HGVS field to None as sample df contains valid HGVS
    df.at[0, "hgvs"] = None

    # Mock existing variant check and API call
    with patch("parkinsons_annotator.modules.data_extraction.existing_variant_check") as mock_check, \
            patch("parkinsons_annotator.modules.data_extraction.extract_clinvar_annotation") as mock_api:
        mock_check.return_value = None

        # Call enrich_clinvar
        df = enrich_clinvar(df, db_session, throttle=0)

        # API should NOT be called when hgvs is missing
        mock_api.assert_not_called()

        # All ClinVar fields should be "Not found in ClinVar"
        for col in CLINVAR_FIELDS.values():
            assert df.at[0, col] == "Not found in ClinVar", \
                f"Field {col} should be 'Not found in ClinVar' when hgvs is missing"

def test_insert_dataframe_to_db_creates_entries(real_session):
    """"insert_dataframe_to_db should create Patient, Gene, Variant, and Connector objects."""

    # Mock data loaded from CSV
    df = pd.DataFrame([
        {
            "vcf_form": "chr1:12345:A>T",
            "gene_symbol": "GENE1",
            "hgvs": "c.123A>T",
            "clinvar_id": "123",
        }
    ])

    # Call insert_dataframe_to_db with real DB session
    insert_dataframe_to_db("Alice", df, real_session)

    # Validate Patient
    patient = real_session.get(Patient, "Alice")
    assert patient is not None

    # Validate Gene
    gene = real_session.get(Genes, "GENE1")
    assert gene is not None

    # Validate Variant
    variant = real_session.get(Variant, "chr1:12345:A>T")
    assert variant is not None
    assert variant.gene_symbol == "GENE1"

    # Validate Link
    link = (
        real_session.query(Connector)
        .filter_by(patient_name="Alice", variant_vcf_form="chr1:12345:A>T")
        .first()
    )
    assert link is not None

def test_load_and_insert_data(real_session, tmp_path, flask_app, monkeypatch):
    """load_and_insert_data should load CSVs and insert into DB."""
    # Configure Flask app upload folder/DB name to mock filepath
    flask_app.config["UPLOAD_FOLDER"] = str(tmp_path)
    flask_app.config["DB_NAME"] = "test.db"
    flask_app.config["TESTING"] = True

    # Patch get_db_session so loader uses the test (real) session
    monkeypatch.setattr(
        "parkinsons_annotator.modules.data_extraction.get_db_session",
        lambda: real_session
    )

    # Create temporary CSVs for 2 patients
    alice_csv = tmp_path / "Alice.csv"
    bob_csv = tmp_path / "Bob.csv"
    # DataFrames to fill CSVs with
    pd.DataFrame([
        {
            "chromosome": "1",
            "position": "12345",
            "id": "PID1",
            "ref": "A",
            "alt": "T"
        }
    ]).to_csv(alice_csv, index=False)

    pd.DataFrame([
        {
            "chromosome": "2",
            "position": "22222",
            "id": "PID2",
            "ref": "G",
            "alt": "C"
        }
    ]).to_csv(bob_csv, index=False)

    # Run inside app context
    with flask_app.app_context():
        load_and_insert_data()

    # Validate that data was inserted into Patient and Variant tables
    assert real_session.get(Patient, "Alice") is not None
    assert real_session.get(Patient, "Bob") is not None

    # Validate that exactly 2 variants were inserted
    variants = real_session.query(Variant).all()
    assert len(variants) == 2

    # Validate that variants were inserted with correct vcf_form
    assert real_session.get(Variant, "1:12345:A:T") is not None
    assert real_session.get(Variant, "2:22222:G:C") is not None
