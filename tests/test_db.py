"""
Tests for database setup functions:
create_db_engine(),
create_tables(),
get_db_session(),
close_db_session(),
has_full_data().

Credit: tests generated by ChatGPT then checked/added to/tested.
"""

import pytest
from pathlib import Path
from flask import Flask
from sqlalchemy import text

from parkinsons_annotator.modules import db
from parkinsons_annotator.modules.models import Base, Patient, Variant, Connector, Genes


### FIXTURES ###

# Test DB name and Flask app
@pytest.fixture
def flask_app(tmp_path):
    app = Flask(__name__)
    app.config["DB_NAME"] = tmp_path / "test.db"
    app.config["TESTING"] = True
    return app

# Clean DB globals between tests
@pytest.fixture(autouse=True)
def clean_db_globals():
    db.engine = None
    db.Session = None
    yield
    if db.Session is not None:
        try:
            db.Session.remove()
        except Exception:
            pass
    if db.engine is not None:
        db.engine.dispose()

# Test create_db_engine()
def test_create_db_engine_without_flask_context(tmp_path, monkeypatch):
    """Engine is created using fallback path when no Flask context."""
    engine = db.create_db_engine()
    assert engine is not None
    assert engine.url.drivername == "sqlite"


def test_create_db_engine_with_flask_context(flask_app):
    """Engine uses Flask config DB_NAME when app context exists."""
    with flask_app.app_context():
        engine = db.create_db_engine()
        assert engine.url.database.endswith("test.db")


# Test create_tables
def test_create_tables_creates_schema(flask_app):
    """Test that create_tables creates database schema."""
    # Call functions within Flask app context
    with flask_app.app_context():
        db.create_db_engine()
        db.create_tables()

        # Verify all expected tables exist
        engine = db.engine
        with engine.connect() as conn:
            for table in ["patients", "variants", "patient_variant"]:
                result = conn.execute(
                    text("SELECT name FROM sqlite_master WHERE type='table' AND name=:t"),
                    {"t": table},
                )
                assert result.fetchone() is not None

# Test get_db_session
def test_get_db_session_no_request_context(flask_app):
    """Returns a non-global session when outside request context."""
    with flask_app.app_context():
        session = db.get_db_session()
        assert session is not None

        # Can execute a query
        session.execute(text("SELECT 1"))
        session.close()


def test_get_db_session_request_context(flask_app):
    """Session is stored in flask.g during request."""
    with flask_app.test_request_context():
        session1 = db.get_db_session()
        session2 = db.get_db_session()

        # Same session reused
        assert session1 is session2

# Test close_db_session
def test_close_db_session_request_context(flask_app):
    """With request context, is able to close session."""
    with flask_app.test_request_context():
        session = db.get_db_session()
        assert session is not None

        db.close_db_session()
        # No exception = success


def test_close_db_session_no_request_context(flask_app):
    """Should only close session if in request context."""
    # With app context instead of request context:
    with flask_app.app_context():
        session = db.get_db_session()
        session.close()  # manual close outside request
        # Should not raise
        db.close_db_session()


# Test has_full_data
def test_has_full_data_returns_false_when_empty(flask_app):
    """Check returns False when database is empty."""
    with flask_app.app_context():
        db.create_db_engine()
        db.create_tables()

        # No data in tables, so should return False
        assert db.has_full_data() is False


def test_has_full_data_returns_true_when_populated(flask_app):
    with flask_app.app_context():
        db.create_db_engine()
        db.create_tables()
        session = db.get_db_session()

        # Parent rows
        p = Patient(name="Alice")
        g = Genes(gene_symbol="GENE", gene_url="")
        v = Variant(
            vcf_form="1:1:A:T",
            hgvs="HGVS1",
            gene_symbol="GENE",
        )

        session.add_all([p, g])
        session.flush()  # ensures Patient + Gene exist

        session.add(v)
        session.flush()  # ensures Variant exists

        # Junction table row
        c = Connector(
            patient_name="Alice",
            variant_vcf_form="1:1:A:T"
        )
        session.add(c)
        session.commit()

        assert db.has_full_data() is True
